package ќсновы.lesson6;

import java.util.Arrays;

public class Task0_SortEl {

	/* ќтсортировать элементы методом сортировки выбором.
	 * 
	 * Ўаги алгоритма:
	 *
     * находим номер минимального значени€ в текущем списке
     * производим обмен этого значени€ со значением первой неотсортированной позиции 
     * (обмен не нужен, если минимальный элемент уже находитс€ на данной позиции)
     * теперь сортируем хвост списка, исключив из рассмотрени€ уже отсортированные элементы
	 * 
	 * ƒл€ реализации устойчивости алгоритма необходимо в пункте 2 минимальный элемент непосредственно 
	 * вставл€ть в первую неотсортированную позицию, не мен€€ пор€док остальных элементов.
	 */

	public static void main(String[] args) {

		int vector [] = {2, 4, 5, 7, 6, 3, 8, 9, 1, 10};
		int vectorSort [] = new int[10];
		
		vectorSort = sortChouse(vector);
		
			System.out.println("ќтсортированый цыкл:");
			System.out.println(Arrays.toString(vectorSort));	
	}
	
	//—равниваем элементы алгоритмом выбора без доп. массива.
	public static int[] sortChouse (int [] vector1) {
		
			// внешний цикл. i Ц позици€ первого неотсортированного элемента на данной итерации.
			for (int i = 0; i < vector1.length-1; i++) { 
				int min = i; // min Ц позици€ минимального элемента.
				
				// внутренний цикл. если найден элемент строго меньший текущего минимального, 
				//	записываем его индекс как минимальный.
				for (int j = i + 1; j < vector1.length; j++) {
		
					if (vector1 [j] < vector1 [min]) { 	// ≈сли мин больше элем. массива.
					
						min = j;	// мин присваиваем номер элемента массива.						
					}
				}
				
				int dummy = vector1[i];
				vector1[i] = vector1[min];
				vector1[min] = dummy;
				
		}
		return vector1;
	}
}
